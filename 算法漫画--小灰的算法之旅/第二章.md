* 物理结构和逻辑结构
1. 物理结构好比人的人体，逻辑结构好比人的精神，逻辑结构是抽象的概念，它依赖于物理结构而存在。
2. 物理结构中包括数组和链表等，数组是顺序存储结构，链表是链式存储结构。
3. 逻辑结构中包括栈和队列等，顺序表、栈、队列是线性结构，图、树是非线性结构。

* 数组和链表的区别
1. 数组--元素之间紧密排列，不能打乱顺序，也不能跳格存储，存储方式是顺序存储。链表--存储空间非连续，可以打乱顺序，存储方式是随机存储；
2. 单向链表中每一个节点都包含 data 和一个指向下一个节点的指针 next，尾节点的 next 指向 null；双向链表中每一个节点不光包含 data 和 next，还包含指向上一个节点的指针 prev，头节点的 prev 指向 null。
3. 
| -- | 查找 | 更新 | 插入 ｜ 删除 ｜
| ----- | :-: | ---: | ---: | ---: | 
| 数组 | O(1) | O(1) | O(n) | O(n) | 
| 链表 | O(n) | O(1) | O(1) | O(1) | 

* 栈和队列的区别
1. 栈：先进后出，类似于一个乒乓球桶；队列：先进先出，类似于一条单行隧道。
2. 栈和队列的数据结构既可以用数组实现，也可以用链表实现。

* 散列表
1. 散列表也叫哈希表，这种数据结构提供了 key 和 value 的映射关系，只要给出了 key，就可以高效的查找到他所匹配的 value，时间复杂度接近于 O(1)。
2. 哈希函数：index = HashCode (Key) % Array.length
3. 哈希冲突：由于数组的长度是有限的，当插入的 Entry 越来越多时，不同的 Key 通过 哈希函数获得的下标有可能是相同的。 例如 002936 这个 Key 对应的数组下标是 2；002947 这个 Key 对应的数组下标也是 2。这种情况，就叫作哈希冲突。
4. 解决哈希冲突的办法：开放寻址法和**链表法**
链表法：将数组的每一个元素都与一个链表对应，当下表冲突的时候，我们可以顺着链表慢慢往下找，看看能否找到与Key相匹配的节点。
5. 
扩容：因为数组的长度有限，当存储的数据越来越多时，每一个元素对应的链表就会越来越长，这个时候就需要对散列表进行扩容。
1. 扩容，创建一个新的Entry空数组，长度是原数组的2倍。 
2. 重新Hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中。为什 么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。